//*******************************************************************************
// Library       : Data Flash Access Library T02
//
// Device(s)     : RL78/G13 (R5F100LE)
// Description   : Linker sample file, please modify according to your device
//******************************************************************************
// DISCLAIMER
// This software is supplied by Renesas Electronics Corporation and is only
// intended for use with Renesas products. No other uses are authorized. This
// software is owned by Renesas Electronics Corporation and is protected under
// all applicable laws, including copyright laws.
// THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
// THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT
// LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
// AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
// TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS
// ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE
// FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR
// ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE
// BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
// Renesas reserves the right, without notice, to make changes to this software
// and to discontinue the availability of this software. By using this software,
// you agree to the additional terms and conditions found by accessing the
// following link:
// http://www.renesas.com/disclaimer
//
// Copyright (C) 2015, 2016 Renesas Electronics Corporation. All rights reserved.
//*******************************************************************************
// CAUTIONS:
//   1.  Do not locate any function arguments, data buffers for FDL or stack
//       to the short address area from 0xFFE20 to 0xFFEDF.
//   2.  It is not allowed to locate any arguments and stack memory
//       to the self-RAM area.
//       For the RAM areas used by the flash library for the given 
//       microcontroller, please consult "Self RAM list of Flash Self-Programming
//       Library for RL78 Family" (R20UT2943(JPN), R20UT2944(ENG))
//   3.  Please also consider further restrictions regarding memory sections 
//       for your target microcontroller (e.g. for on-chip debugging and
//       the mirror area). 
//       For details, please consult the "User's Manual: Hardware" of your target
//       microcontroller.
//
// SECTIONS:
//   1.  FDL_CODE: contain the actual library code of the Tiny FDL
//       This section should not be mapped across any boundary of 64KB Flash page.
//   2.  FDL_CNST: contain the constants used by the Tiny FDL
//       This section should not be mapped across any boundary of 64KB Flash page.
//   3.  FDL_SDAT: contain all FDL-internal variables used by the Tiny FDL
//       This section must be mapped in the short address RAM.
//*******************************************************************************

// Please note that below mapping is only a sample for RL78/G13 (R5F100LE) and
// might need to be adapted to your microcontroller

initialize by copy with packing = auto { rw };
initialize manually { ro section .const, ro section .switch };
do not initialize  { section *.noinit };

define memory mem with size = 1M;

define region ROM_near = mem:[from 0x000D8 to 0x0FFFF];
define region ROM_far  = mem:[from 0x000D8 to 0x0FFFF];
define region ROM_huge = mem:[from 0x000D8 to 0x0FFFF];
define region SADDR    = mem:[from 0xFFE20 to 0xFFEDF];
define region RAM_near = mem:[from 0xFF300 to 0xFFE1F];
define region RAM_far  = mem:[from 0xFF300 to 0xFFE1F];
define region RAM_huge = mem:[from 0xFF300 to 0xFFE1F];
define region VECTOR   = mem:[from 0x00000 to 0x0007F];
define region CALLT    = mem:[from 0x00080 to 0x000BF];
define region EEPROM   = mem:[from 0xF1000 to 0xF1FFF];

define block NEAR_HEAP with alignment = 2, size = _NEAR_HEAP_SIZE {  };
define block FAR_HEAP  with alignment = 2, size = _FAR_HEAP_SIZE {  };
define block HUGE_HEAP with alignment = 2, size = _HUGE_HEAP_SIZE {  };
define block CSTACK    with alignment = 2, size = _STACK_SIZE { rw section CSTACK };
define block INIT_ARRAY with alignment = 2, fixed order { ro section .preinit_array,
                                                          ro section .init_array };
define block MIRROR_ROM with maximum size = _NEAR_CONST_LOCATION_SIZE { ro section .const_init,
                                                                        ro section .switch_init };
define block MIRROR_RAM with maximum size = _NEAR_CONST_LOCATION_SIZE { rw section .const,
                                                                        rw section .switch };
define block OPT_BYTE with size = 4  { ro section .option_byte,
                                       ro section OPTBYTE };
define block SECUR_ID with size = 10 { ro section .security_id,
                                       ro section SECUID };
define block OCD_ROM_AREA with alignment = 2, size = 0x0200 {  };


place at address mem:0x00000       { ro section .intvec };
place at address mem:0x000C0       { block OPT_BYTE };
place at address mem:0x000C4       { block SECUR_ID };
place at address mem:0x0FE00       { block OCD_ROM_AREA };
place at address mem:_NEAR_CONST_LOCATION_START             { block MIRROR_ROM };
place at address mem:(_NEAR_CONST_LOCATION_START | 0xF0000) { block MIRROR_RAM };

"CALLT":place in CALLT             { ro section .callt0 };

"ROMNEAR":place in ROM_near        { ro section .text};

"ROMFAR":place in ROM_far          { block INIT_ARRAY,
                                     rw section .text_unit64kp,
                                     ro section FDL_CODE,
                                     ro section FDL_CNST,
                                     ro section .constf,
                                     ro section .switchf,
                                     ro };

"ROMHUGE":place in ROM_huge        { ro section .consth,
                                     ro section .textf };

"RAMNEAR":place in RAM_near        { block NEAR_HEAP,
                                     block CSTACK,
                                     zi section .iar.dynexit,
                                     rw section .data,
                                     rw section .bss*,
                                     rw };

"RAMFAR":place in RAM_far          { block FAR_HEAP,
                                     rw section .dataf,
                                     rw section .data_unit64kp,
                                     rw section .bss_unit64kp,
                                     rw section .bssf* };

"RAMHUGE":place in RAM_huge        { block HUGE_HEAP,
                                     rw section .hdata,
                                     rw section .hbss* };

"SADDRMEM":place in SADDR          { rw section .sdata,
                                     rw section .sbss,
                                     rw section FDL_SDAT,
                                     rw section .wrkseg };

// Set the symbol __RESERVE_OCD_ROM to 1 to reserve the OCD area for debugging.
// IDE: Symbol can be defined within the project settings here:
//      "Project"-->"Options..."->"Linker"-->"Config"-->"Configuration file symbol definitions"
//      Symbol definition: __RESERVE_OCD_ROM=1
// Command line: --config_def __RESERVE_OCD_ROM=1

if (isdefinedsymbol(__RESERVE_OCD_ROM))
{
  if (__RESERVE_OCD_ROM == 1)
  {
    keep { block OCD_ROM_AREA };
  }
}

